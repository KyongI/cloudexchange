.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CFDEFC 1"
.TH CFDEFC 1 "2015-08-20" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
cfdefc \- PFC configuration definition file compiler
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  cfdefc [options] cfdef_file
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
\&\s-1PFC\s0 configuration file system requires configuration definition file
(cfdef file). \fBcfdefc\fR converts cfdef file into C language code which contains
pfc_cfdef_t, which determines the syntax of the configuration file.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBcfdefc\fR takes one cfdef file path as argument, and compiles it.
.PP
The options for \fBcfdefc\fR are:
.IP "\fB\-o\fR|\fB\-\-output\fR \fIfile\fR" 4
.IX Item "-o|--output file"
Specify filename to dump C language code.
.Sp
If omitted, \fBcfdefc\fR tries to detect output filename from input filename.
In this case, input filename must have '.cfdef' as suffix. If 'foo.cfdef' is
specified as input filename, output filename will be 'foo.c'.
.IP "\fB\-c\fR|\fB\-\-cpp\fR \fIcpp\fR" 4
.IX Item "-c|--cpp cpp"
Specify path to C preprocessor.
.Sp
If this option is specified, the cfdef file is filtered by C preprocessor
before parsing.
.IP "\fB\-C\fR|\fB\-\-cppflag\fR \fIflag\fR" 4
.IX Item "-C|--cppflag flag"
Specify option for C preprocessor.
.Sp
If \fB\-L\fR option is specified, "\fB\-DPFC_LP64=1\fR\*(L" is automatically added to
C preprocessor flags. So you can use \*(R"#ifdef \s-1PFC_LP64"\s0 in the cfdef file
to define \s-1LP64\s0 specific parameter.
.Sp
This option is ignored unless \fB\-c\fR option is specified.
.IP "\fB\-D\fR|\fB\-\-depfile\fR \fIfile\fR" 4
.IX Item "-D|--depfile file"
Specify file to store header file dependencies.
.Sp
If this option is specified, \fBcfdefc\fR generates a rule suitable for
\&\fBmake\fR program describing the header file dependencies of the cfdef file.
.Sp
This option is ignored unless \fB\-c\fR option is specified.
.IP "\fB\-L\fR|\-\fB\-\-LP64\fR" 4
.IX Item "-L|---LP64"
Create definition for \s-1LP64\s0 system.
.IP "\fB\-n\fR|\fB\-\-name\fR \fIname\fR" 4
.IX Item "-n|--name name"
Force to use the given \fIname\fR as a symbol name for \fIpfc_cfdef_t\fR struct.
.Sp
If this option is specified, the \fIname\fR directive in the cfdef file is
ignored.
.IP "\fB\-v\fR|\fB\-\-visibility\fR \fIvisibility\fR" 4
.IX Item "-v|--visibility visibility"
Force to change symbol visibility for pfc_cfdef_t struct.
.Sp
\&\fIvisibility\fR must be one of the followings:
.RS 4
.IP "default" 4
.IX Item "default"
Use default visibility.
This is the default.
.IP "hidden" 4
.IX Item "hidden"
Use hidden visibility.
.RE
.RS 4
.RE
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
Show supported command line options.
.IP "\fB\-\-doc\fR" 4
.IX Item "--doc"
Show this document.
.SH "CFDEF FILE FORMAT"
.IX Header "CFDEF FILE FORMAT"
\&\s-1PFC\s0 configuration file consists of \fIblock\fR and \fImap\fR.
The following is the format of block in the configuration file.
.PP
.Vb 4
\&  <block\-name> {
\&      <parameters>;
\&      ...
\&  }
.Ve
.PP
Each block has unique name and one or more parameters.
Block name must be unique in the configuration file.
Parameters are pairs of name and value combined with '=' character,
and it ends with ';'.
.PP
The following example defines a block named \*(L"options\*(R",
and parameters \*(L"int_value\*(R" and \*(L"string_value\*(R". Value of \*(L"int_value\*(R" is 1,
and value of \*(L"string_value\*(R" is \*(L"default\*(R".
.PP
.Vb 4
\&  options {
\&      int_value    = 1;
\&      string_value = "default";
\&  }
.Ve
.PP
The following is the format of map in the configuration file.
.PP
.Vb 4
\&  <map\-name> <name> {
\&      <parameters>;
\&      ...
\&  }
.Ve
.PP
<map\-name> defines the name of map, and <name> defines the key of map block.
Name of map must be unique in the configuration file, and name parameter must
be unique in the same map. That is, map acts like hash table which associates
parameter block with unique name.
.PP
The following example defines a map named \*(L"maps\*(R".
\&\*(L"maps\*(R" has the two keys, \*(L"foo\*(R" and \*(L"bar\*(R".
Each parameter block in the map has two parameters, \*(L"int_value\*(R" and
\&\*(L"string_value\*(R". Values of \*(L"int_value\*(R" and \*(L"string_value\*(R" associated with the
map key \*(L"foo\*(R" is 1 and \*(L"value1\*(R", values associated with the map key \*(L"bar\*(R" is
2 and \*(L"value2\*(R".
.PP
.Vb 4
\&  maps "foo" {
\&      int_value    = 1;
\&      string_value = "value1";
\&  }
\&
\&  maps "bar" {
\&      int_value    = 2;
\&      string_value = "value2";
\&  }
.Ve
.PP
Note that characters between '%' and the end of line are considered
as comment.
.SS "\s-1HOW TO DEFINE BLOCK\s0"
.IX Subsection "HOW TO DEFINE BLOCK"
To define a block, you must put \fIdefblock\fR directive in in the cfdef file.
.PP
.Vb 4
\&  defblock <block\-name> {
\&      <param\-def>;
\&      ...
\&  }
.Ve
.PP
<block\-name> is the name of block. <param\-def> defines parameters in this
block. The format of <param\-def> is described later.
.PP
The name of block has the following constraints:
.IP "\-" 2
It must starts with an alphabet.
.IP "\-" 2
It must consists of alphabet, digits, and underscore character ('_').
.IP "\-" 2
The length of block name must be less than 64.
.PP
If the cfdef file contains the following definition,
.PP
.Vb 3
\&  defblock options {
\&      ...
\&  }
.Ve
.PP
the configuration file can have one block named \*(L"options\*(R".
.PP
.Vb 3
\&  options {
\&      ...
\&  }
.Ve
.SS "\s-1HOW TO DEFINE MAP\s0"
.IX Subsection "HOW TO DEFINE MAP"
Use \fIdefmap\fR directive instead of \fIdefblock\fR.
.PP
.Vb 4
\&  defmap <map\-name> {
\&      <param\-def>;
\&      ...
\&  }
.Ve
.PP
<map\-name> is the name of map. The name of map has the same constraints as
the name of block. Note that the same name can't be used for the block and
the map.
.PP
If the cfdef file contains the following definition,
.PP
.Vb 3
\&  defmap maps {
\&      ...
\&  }
.Ve
.PP
the configuration file can have maps named \*(L"maps\*(R".
You can put more than two maps as long as they have unique name.
.PP
.Vb 3
\&  maps "foo" {
\&      ...
\&  }
\&
\&  maps "bar" {
\&      ...
\&  }
.Ve
.SS "\s-1HOW TO DEFINE PARAMETERS\s0"
.IX Subsection "HOW TO DEFINE PARAMETERS"
The following is the format of parameter definition.
.PP
.Vb 1
\&  <param\-name> = <param\-type> <param\-options>;
.Ve
.PP
<param\-name> is the name of parameter, and <param\-type> is a symbol which
determines data type of parameter. <param\-options> are optional definitions
for the parameter. More than two options can be defined by specifying options
separated by comma.
.PP
\fI\s-1INTEGER PARAMETER\s0\fR
.IX Subsection "INTEGER PARAMETER"
.PP
If you want to define parameter which takes integer value, you must choose
one parameter type from the followings.
.IP "\fB\s-1BYTE\s0\fR" 4
.IX Item "BYTE"
Parameter takes a byte value. A byte value is considered as unsigned 8\-bit
value.
.IP "\fB\s-1INT32\s0\fR" 4
.IX Item "INT32"
Parameter takes a signed 32\-bit value.
.IP "\fB\s-1UINT32\s0\fR" 4
.IX Item "UINT32"
Parameter takes an unsigned 32\-bit value.
.IP "\fB\s-1INT64\s0\fR" 4
.IX Item "INT64"
Parameter takes a signed 64\-bit value.
.IP "\fB\s-1UINT64\s0\fR" 4
.IX Item "UINT64"
Parameter takes an unsigned 64\-bit value.
.IP "\fB\s-1LONG\s0\fR" 4
.IX Item "LONG"
Parameter takes a signed long integer value.
On \s-1LP64\s0 system, this type is identical to \s-1INT64.\s0
Otherwise it is identical to \s-1INT32.\s0
.IP "\fB\s-1ULONG\s0\fR" 4
.IX Item "ULONG"
Parameter takes an unsigned long integer value.
On \s-1LP64\s0 system, this type is identical to \s-1UINT64.\s0
Otherwise it is identical to \s-1UINT32.\s0
.PP
An integer value can be specified in the following format.
.IP "\-" 2
If the value starts with \*(L"0x\*(R", it is considered as hexadecimal format.
.IP "\-" 2
If the value starts with \*(L"0\*(R", it is considered as octal format.
.IP "\-" 2
Otherwise, it is considered as decimal format.
.PP
For example, the following line in the cfdef file defines a parameter
named \*(L"int32_value\*(R", and its type is signed 32\-bit integer.
.PP
.Vb 1
\&  int32_value = INT32;
.Ve
.PP
Value for this parameter can be specified in the configuration file like this:
.PP
.Vb 1
\&  int32_value = 0x10;
.Ve
.PP
\fI\s-1BOOLEAN PARAMETER\s0\fR
.IX Subsection "BOOLEAN PARAMETER"
.PP
If you want to define parameter which takes boolean value, you must specify
\&\fB\s-1BOOL\s0\fR as parameter type.
.PP
A boolean value is specified by \fItrue\fR or \fIfalse\fR. \fItrue\fR means a true
value, and \fIfalse\fR a false.
.PP
For example, the following line in the cfdef file defines a boolean pamrater
named \*(L"bool_value\*(R".
.PP
.Vb 1
\&  bool_value = BOOL;
.Ve
.PP
The following line in the configuration file defines value for \*(L"bool_value\*(R"
parameter as true.
.PP
.Vb 1
\&  bool_value = true;
.Ve
.PP
\fI\s-1STRING PARAMETER\s0\fR
.IX Subsection "STRING PARAMETER"
.PP
If you want to define parameter which takes string value, you must specify
\&\fB\s-1STRING\s0\fR as parameter type.
.PP
A string value is specified by a quoted string, quoted by double quotation
mark. Supported encodings are US-ASCII and \s-1UTF\-8.\s0 Just like C language style
string, backslash escape can be used in a string, but only the followings are
supported.
.IP "\er" 4
.IX Item "r"
Carriage return
.IP "\en" 4
.IX Item "n"
Line feed (new line)
.IP "\et" 4
.IX Item "t"
Horizontal tab
.IP "\e'" 4
.IX Item "'"
Single quotation mark
.IP "\e""" 4
.IX Item """"
Double quotation mark
.IP "\e\e" 4
.IX Item ""
Backslash character
.PP
For example, the following line in the cfdef file defines a string parameter
named \*(L"string_value\*(R".
.PP
.Vb 1
\&  string_value = STRING;
.Ve
.PP
The following line in the configuration file defines value for \*(L"string_value\*(R"
parameter as \*(L"value\*(R".
.PP
.Vb 1
\&  string_value = "value";
.Ve
.PP
\fI\s-1ARRAY PARAMETER\s0\fR
.IX Subsection "ARRAY PARAMETER"
.PP
A parameter can have array type, which takes a sequence of values.
If '[]' is specified just after parameter type, it is considered as an array
parameter. If a number is specified in square bracket, it is considered as
the size of an array. If not, it is considered as variable-length array.
.PP
For example, the following line in the cfdef file defines a parameter
\&\*(L"int32_array\*(R" which has variable-length int32 value.
.PP
.Vb 1
\&  int32_array = INT32[];
.Ve
.PP
The following line in the cfdef file determines the size of array elements
as 4. If the number of elements specified in the configuration file is not 4,
the parser will cause a fatal error.
.PP
.Vb 1
\&  int32_array = INT32[4];
.Ve
.PP
In the configuration file, value of array can be specified by square bracket
and comma-separated value like this.
.PP
.Vb 1
\&  int32_array = [1, 2, 3, 4];
.Ve
.PP
\fI\s-1PARAMETER OPTIONS\s0\fR
.IX Subsection "PARAMETER OPTIONS"
.PP
Each parameter definition has one or more options.
If you want to define options for a parameter, you must put ':' between
parameter type and option list.
.PP
The following is the supported options:
.IP "\fImandatory\fR" 4
.IX Item "mandatory"
This option declares the parameter is mandatory.
The configuration file parser causes fatal error if at least one mandatory
option is not defined in the configuration file.
.Sp
The following example declares \*(L"int32_value\*(R" as mandatory.
.Sp
.Vb 1
\&  int32_value = INT32: mandatory;
.Ve
.IP "\fImin\fR" 4
.IX Item "min"
This option declares the minimum value of the parameter.
The configuration file parser causes fatal error if the parameter value is
less than this value.
.RS 4
.IP "\-" 2
This option can't be specified to boolean parameter.
.IP "\-" 2
If this option is specified to string parameter, the value of this option
is considered as the minimum length of the parameter.
.IP "\-" 2
If this option is specified to array parameter, this constraint is applied
to all array elements.
.RE
.RS 4
.RE
.IP "\fImax\fR" 4
.IX Item "max"
This option declares the maximum value of the parameter.
The configuration file parser causes fatal error if the parameter value is
greater than this value.
.RS 4
.IP "\-" 2
This option can't be specified to boolean parameter.
.IP "\-" 2
If this option is specified to string parameter, the value of this option
is considered as the maximum length of the parameter.
.IP "\-" 2
If this option is specified to array parameter, this constraint is applied
to all array elements.
.RE
.RS 4
.Sp
The following example declares \*(L"int32_value\*(R" which can take a value between
\&\-10 and 10.
.Sp
.Vb 1
\&  int32_value = INT32: min=\-10, max=10;
.Ve
.RE
.SS "C \s-1LANGUAGE SYMBOL\s0"
.IX Subsection "C LANGUAGE SYMBOL"
\&\fBcfdefc\fR constructs \fIpfc_cfdef_t\fR struct in the C language source file.
The definition of \fIpfc_cfdef_t\fR can be controlled by the cfdef file directive.
.IP "\fBcf_name\fR" 4
.IX Item "cf_name"
The name of \fIpfc_cfdef_t\fR struct can be specified by \fBcf_name\fR directive.
.Sp
The following example specifies the name of \fIpfc_cfdef_t\fR struct as
\&\*(L"pfc_cfdef\*(R".
.Sp
.Vb 1
\&  cf_name = pfc_cfdef;
.Ve
.Sp
If a \fBcf_name\fR directive is not specified, the name of \fIpfc_cfdef_t\fR
struct is determined by the cfdef filename, replacing all '.' in filename
with '_'.
.Sp
If the cfdef filename is \*(L"foo.cfdef\*(R", the default \fIpfc_cfdef_t\fR struct name
is \*(L"foo_cfdef\*(R".
.IP "\fBcf_visibility\fR" 4
.IX Item "cf_visibility"
Symbol visibility of \fIpfc_cfdef_t\fR can be specified by \fBcf_visibility\fR
directive.
.Sp
The following example changes visibility of \fIpfc_cfdef_t\fR struct to hidden.
.Sp
.Vb 1
\&  cf_visibility = hidden;
.Ve
.Sp
Currently, supported visibilities are \fIdefault\fR and \fIhidden\fR.
If omitted, the default visibility is used.
.SS "\s-1REMARKS\s0"
.IX Subsection "REMARKS"
.IP "\-" 4
\&\fBcfdefc\fR limits the length of string parameter to 1023.
If a value larger than 1023 is specified for \fB\s-1STRING\s0\fR parameter's
\&\fImin\fR or \fImax\fR option, \fBcfdefc\fR causes a fatal error.
.IP "\-" 4
\&\fBcfdefc\fR limits the number of array elements to 256.
If a value larger than 256 is specified for the number of array elements.
\&\fBcfdefc\fR causes a fatal error.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1NEC\s0 Corporation
