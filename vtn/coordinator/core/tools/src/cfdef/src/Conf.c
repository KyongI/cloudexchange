/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Conf.xs. Do not edit this file, edit Conf.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Conf.xs"
/*
 * Copyright (c) 2010-2013 NEC Corporation
 * All rights reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/*
 * Native library for PFC::Conf.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <pfc/base.h>

#define	CLASS_PFC_CONF_INTEGER		"PFC::Conf::Integer"

/* String length enough to represent 64-bit integer. */
#define	INTEGER_STRSIZE		32

/*
 * Integer data type.
 */
typedef struct {
	const char	*ct_name;		/* name of type */
	uint8_t		ct_bits;		/* bit width */
	uint8_t		ct_unsigned;		/* unsigned value */
} conf_inttype_t;

static const conf_inttype_t	inttype_defs[] = {
	{ "BYTE", 8, 1},
	{ "INT32", 32, 0},
	{ "UINT32", 32, 1},
	{ "INT64", 64, 0},
	{ "UINT64", 64, 1},
	{ "LONG", 0, 0},
	{ "ULONG", 0, 1},
};

/* Bit width of LONG type.. */
static uint8_t	conf_long_width = 64;

/*
 * Return bit width of the specified conf_inttype_t.
 */
#define	PFC_CONF_INTTYPE_WIDTH(tp)					\
	(((tp)->ct_bits == 0) ? conf_long_width : (tp)->ct_bits)

/*
 * Instance of PFC::Conf::Integer.
 */
typedef struct {
	uint64_t		ci_value;	/* absolute value */
	const conf_inttype_t	*ci_type;	/* value type */
	uint8_t			ci_minus;	/* true if negative value */
} conf_integer_t;

#define	PFC_CONF_INTEGER_NEW(var)	Newx((var), 1, conf_integer_t)

/*
 * static int
 * conf_integer_validate(conf_integer_t *obj)
 *	Validate an integer value in the specified object.
 *	If not valid, an exception is thrown and zero is returned.
 */
static int
conf_integer_validate(conf_integer_t *obj)
{
	const conf_inttype_t	*tp = obj->ci_type;
	uint8_t	bits = PFC_CONF_INTTYPE_WIDTH(tp);

	if (obj->ci_value == 0) {
		obj->ci_minus = 0;
	}

	if (tp->ct_unsigned) {
		if (obj->ci_minus) {
			croak("%s: Value must be positive.\n", tp->ct_name);

			return 0;
		}
		if (bits != 64) {
			uint64_t	max = ((1ULL << bits) - 1);

			if (obj->ci_value > max) {
				croak("%s: Integer overflow.\n", tp->ct_name);

				return 0;
			}
		}
	}
	else if (obj->ci_minus) {
		uint64_t	max = (1ULL << (bits - 1));

		if (obj->ci_value > max) {
			croak("%s: Integer underflow.\n", tp->ct_name);

			return 0;
		}
	}
	else {
		uint64_t	max = ((1ULL << (bits - 1)) - 1);

		if (obj->ci_value > max) {
			croak("%s: Integer overflow.\n", tp->ct_name);

			return 0;
		}
	}

	return 1;
}

/*
 * static int
 * conf_integer_from_string(conf_integer_t *obj, const char *string)
 *	Convert string representation of integer into integer value.
 *	If the given string is invalid, an exception is thrown and zero is
 *	returned.
 */
static int
conf_integer_from_string(conf_integer_t *obj, const char *string)
{
	unsigned long long	ull;
	const char		*str;
	const conf_inttype_t	*tp;
	char		*p;

	tp = obj->ci_type;

	/* Determine the value is positive or not. */
	if (*string == '-') {
		obj->ci_minus = 1;
		str = string + 1;
	}
	else {
		obj->ci_minus = 0;
		str = string;
	}

	/* Ensure that no more sign character. */
	for (p = (char *)str; *p != '\0'; p++) {
		if (*p == '-') {
			croak("%s: Illegal character in a string.\n",
			      tp->ct_name);

			return 0;
		}
	}

	errno = 0;
	ull = strtoull(str, &p, 0);
	if (*p != '\0') {
		croak("%s: Illegal integer value: %s\n", tp->ct_name, string);

		return 0;
	}
	if (errno != 0) {
		croak("%s: Could not convert string to integer: %s\n",
		      tp->ct_name, string);

		return 0;
	}

	obj->ci_value = (uint64_t)ull;

	return conf_integer_validate(obj);
}

/*
 * static conf_integer_t *
 * conf_integer_get(SV *sv)
 *	Convert the given SV into PFC::Conf::Integer instance.
 *	NULL is returned if the given SV is not PFC::Conf::Integer instance.
 */
static conf_integer_t *
conf_integer_get(SV *sv)
{
	if (sv_derived_from(sv, CLASS_PFC_CONF_INTEGER)) {
		return (conf_integer_t *)(uintptr_t)(SvIV(SvRV(sv)));
	}

	return NULL;
}

/*
 * static conf_integer_t *
 * conf_integer_instance(SV *sv)
 *	Convert the given SV into PFC::Conf::Integer instance.
 *	An exception will be thrown if the given SV is not PFC::Conf::Integer
 *	instance.
 */
static conf_integer_t *
conf_integer_instance(SV *sv)
{
	conf_integer_t	*obj = conf_integer_get(sv);

	if (PFC_EXPECT_TRUE(obj != NULL)) {
		return obj;
	}

	croak("A reference to " CLASS_PFC_CONF_INTEGER " is required.");

	return NULL;
}

#line 225 "Conf.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 367 "Conf.c"

XS_EUPXS(XS_PFC__Conf__Integer_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PFC__Conf__Integer_new)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 230 "Conf.xs"
	conf_integer_t	*me, newbuf;
#line 377 "Conf.c"
	conf_integer_t *	RETVAL;
#line 232 "Conf.xs"
	newbuf.ci_value = 0;
	newbuf.ci_minus = 0;
	newbuf.ci_type = &inttype_defs[0];

	if (items > 1) {
		if (items >= 3) {
			uint32_t	type;

			if (SvUOK(ST(2))) {
				type = (uint32_t)SvUV(ST(2));
			}
			else if (SvIOK(ST(2))) {
				type = (uint32_t)SvIV(ST(2));
			}
			else {
				/* Internal error */
				croak(CLASS_PFC_CONF_INTEGER
				      ": An integer type must be specified.\n");
			}

			if (type >= PFC_ARRAY_CAPACITY(inttype_defs)) {
				croak("Invalid integer type: %u\n", type);
			}
			newbuf.ci_type = &inttype_defs[type];
		}

		if (SvPOK(ST(1))) {
			const char	*str;

			str = (const char *)SvPV_nolen(ST(1));
			conf_integer_from_string(&newbuf, str);
		}
		else if (SvUOK(ST(1))) {
			newbuf.ci_value = (uint64_t)SvUV(ST(1));
			newbuf.ci_minus = 0;
			conf_integer_validate(&newbuf);
		}
		else if (SvIOK(ST(1))) {
			IV	v = SvIV(ST(1));

			if (v < 0) {
				newbuf.ci_value = (uint64_t)(-v);
				newbuf.ci_minus = 1;
			}
			else {
				newbuf.ci_value = (uint64_t)v;
				newbuf.ci_minus = 0;
			}
			conf_integer_validate(&newbuf);
		}
		else {
			/* Internal error */
			croak(CLASS_PFC_CONF_INTEGER
			      ": A string must be specified.\n");
		}

	}

	PFC_CONF_INTEGER_NEW(me);
	*me = newbuf;
	RETVAL = me;
#line 441 "Conf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS_PFC_CONF_INTEGER, (void *)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PFC__Conf__Integer_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PFC__Conf__Integer_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "me");
    {
	conf_integer_t *	me = conf_integer_instance(ST(0))
;
#line 304 "Conf.xs"
	Safefree(me);
#line 460 "Conf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PFC__Conf__Integer_stringify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PFC__Conf__Integer_stringify)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "me, ...");
    {
	conf_integer_t *	me = conf_integer_instance(ST(0))
;
#line 314 "Conf.xs"
	char	buf[INTEGER_STRSIZE];
	int	buflen;
#line 478 "Conf.c"
	SV *	RETVAL;
#line 317 "Conf.xs"
	buflen = snprintf(buf, sizeof(buf), "%s%" PFC_PFMT_u64,
			  (me->ci_minus) ? "-" : "", me->ci_value);
	if (buflen >= sizeof(buf)) {
		/* This should not happen. */
		buflen = sizeof(buf) - 1;
		buf[buflen] = '\0';
	}
	RETVAL = newSVpvn(buf, buflen);
#line 489 "Conf.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PFC__Conf__Integer_compare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PFC__Conf__Integer_compare)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "me, o, ...");
    {
	conf_integer_t *	me = conf_integer_instance(ST(0))
;
	SV *	o = ST(1)
;
#line 337 "Conf.xs"
	IV		ret;
	uint8_t		minus, cm;
	uint64_t	value, cv;
	conf_integer_t	*obj, objbuf;
#line 513 "Conf.c"
	IV	RETVAL;
	dXSTARG;
#line 342 "Conf.xs"
	if ((obj = conf_integer_get(o)) == NULL) {
		obj = &objbuf;

		obj->ci_minus = 0;
		if (SvUOK(ST(1))) {
			obj->ci_value = (uint64_t)SvUV(ST(1));
		}
		else if (SvIOK(ST(1))) {
			IV	v = SvIV(ST(1));

			if (v < 0) {
				v *= -1;
				obj->ci_minus = 1;
			}
			obj->ci_value = (uint64_t)v;
		}
		else {
			/* Internal error */
			die(CLASS_PFC_CONF_INTEGER
			    ": compare: An integer must be specified.");
		}
	}

	minus = me->ci_minus;
	value = me->ci_value;
	cm = obj->ci_minus;
	cv = obj->ci_value;

	if (minus > cm) {
		ret = -1;
	}
	else if (minus < cm) {
		ret = 1;
	}
	else if (minus) {
		/* Both values are negative. */
		if (value < cv) {
			ret = 1;
		}
		else if (value > cv) {
			ret = -1;
		}
		else {
			ret = 0;
		}
	}
	else {
		/* Both values are positive. */
		if (value < cv) {
			ret = -1;
		}
		else if (value > cv) {
			ret = 1;
		}
		else {
			ret = 0;
		}
	}

	if (items >= 3 && SvTRUE(ST(2))) {
		/* The caller passed reverse flag. */
		ret *= -1;
	}

	RETVAL = ret;
#line 582 "Conf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PFC__Conf__Integer_getHexValue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PFC__Conf__Integer_getHexValue)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "me, ...");
    {
	conf_integer_t *	me = conf_integer_instance(ST(0))
;
#line 418 "Conf.xs"
	char		buf[INTEGER_STRSIZE];
	int		buflen;
	uint64_t	value;
#line 602 "Conf.c"
	SV *	RETVAL;
#line 422 "Conf.xs"
	if (me->ci_minus) {
		int64_t	v = (int64_t)me->ci_value * -1;
		value = (uint64_t)v;
	}
	else {
		value = me->ci_value;
	}
	buflen = snprintf(buf, sizeof(buf), "0x%" PFC_PFMT_x64, value);
	if (buflen >= sizeof(buf)) {
		/* This should not happen. */
		buflen = sizeof(buf) - 1;
		buf[buflen] = '\0';
	}
	RETVAL = newSVpvn(buf, buflen);
#line 619 "Conf.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PFC__Conf__Integer_getMinHexValue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PFC__Conf__Integer_getMinHexValue)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "me, ...");
    {
	conf_integer_t *	me = conf_integer_instance(ST(0))
;
#line 447 "Conf.xs"
	char		buf[INTEGER_STRSIZE];
	int		buflen;
	const conf_inttype_t	*tp;
#line 640 "Conf.c"
	SV *	RETVAL;
#line 451 "Conf.xs"
	tp = me->ci_type;
	if (tp->ct_unsigned) {
		buflen = snprintf(buf, sizeof(buf), "0x0");
	}
	else {
		uint64_t	value;
		uint8_t		bits = PFC_CONF_INTTYPE_WIDTH(tp);

		if (bits == 64) {
			value = (1ULL << 63);
		}
		else {
			value = (uint64_t)-1 & ~((1ULL << (bits - 1)) - 1);
		}

		buflen = snprintf(buf, sizeof(buf), "0x%" PFC_PFMT_x64, value);
	}
	if (buflen >= sizeof(buf)) {
		/* This should not happen. */
		buflen = sizeof(buf) - 1;
		buf[buflen] = '\0';
	}
	RETVAL = newSVpvn(buf, buflen);
#line 666 "Conf.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PFC__Conf__Integer_getMaxHexValue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PFC__Conf__Integer_getMaxHexValue)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "me, ...");
    {
	conf_integer_t *	me = conf_integer_instance(ST(0))
;
#line 485 "Conf.xs"
	char		buf[INTEGER_STRSIZE];
	int		buflen;
	uint64_t	value;
	uint8_t		bits;
	const conf_inttype_t	*tp;
#line 689 "Conf.c"
	SV *	RETVAL;
#line 491 "Conf.xs"
	tp = me->ci_type;
	bits = PFC_CONF_INTTYPE_WIDTH(tp);
	if (tp->ct_unsigned) {
		if (bits == 64) {
			value = (uint64_t)-1;
		}
		else {
			value = (1ULL << bits) - 1;
		}
	}
	else {
		value = (1ULL << (bits - 1)) - 1;
	}
	buflen = snprintf(buf, sizeof(buf), "0x%" PFC_PFMT_x64, value);
	if (buflen >= sizeof(buf)) {
		/* This should not happen. */
		buflen = sizeof(buf) - 1;
		buf[buflen] = '\0';
	}
	RETVAL = newSVpvn(buf, buflen);
#line 712 "Conf.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PFC__Conf_LP64); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PFC__Conf_LP64)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 525 "Conf.xs"
	IV	ret = 1;
#line 728 "Conf.c"
	IV	RETVAL;
	dXSTARG;
#line 527 "Conf.xs"
	if (items >= 1) {
		if (SvTRUE(ST(0))) {
			/* The target is LP64. */
			conf_long_width = 64;
		}
		else {
			/* The target is ILP32. */
			conf_long_width = 32;
		}
	}

	if (conf_long_width != 64) {
		XSRETURN_UNDEF;
	}
	RETVAL = ret;
#line 747 "Conf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_PFC__Conf); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_PFC__Conf)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("PFC::Conf::Integer::new", XS_PFC__Conf__Integer_new, file);
        newXS("PFC::Conf::Integer::DESTROY", XS_PFC__Conf__Integer_DESTROY, file);
        newXS("PFC::Conf::Integer::stringify", XS_PFC__Conf__Integer_stringify, file);
        newXS("PFC::Conf::Integer::compare", XS_PFC__Conf__Integer_compare, file);
        newXS("PFC::Conf::Integer::getHexValue", XS_PFC__Conf__Integer_getHexValue, file);
        newXS("PFC::Conf::Integer::getMinHexValue", XS_PFC__Conf__Integer_getMinHexValue, file);
        newXS("PFC::Conf::Integer::getMaxHexValue", XS_PFC__Conf__Integer_getMaxHexValue, file);
        newXS("PFC::Conf::LP64", XS_PFC__Conf_LP64, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

